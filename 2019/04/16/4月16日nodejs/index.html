<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="4月16日nodejs(一)"><meta name="keywords" content="后端,node.js"><meta name="author" content="Shuyan Jing"><meta name="copyright" content="Shuyan Jing"><title>4月16日nodejs(一) | 拉斐尔</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-js简介"><span class="toc-number">1.</span> <span class="toc-text">Node.js简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特点"><span class="toc-number">3.</span> <span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单线程"><span class="toc-number">3.1.</span> <span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非阻塞I-O-non-blocking-I-O"><span class="toc-number">3.2.</span> <span class="toc-text">非阻塞I/O non-blocking I/O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件驱动event-driven"><span class="toc-number">3.3.</span> <span class="toc-text">事件驱动event-driven</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单线程，单线程的好处，减少了内存开销，操作系统的内存换页。"><span class="toc-number">3.4.</span> <span class="toc-text">单线程，单线程的好处，减少了内存开销，操作系统的内存换页。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#适合开发什么？"><span class="toc-number">4.</span> <span class="toc-text">适合开发什么？</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP模块"><span class="toc-number"></span> <span class="toc-text">HTTP模块</span></a></li></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Shuyan Jing</div><div class="author-info__description text-center">自学前端的小白 弟中弟</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">拉斐尔</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">4月16日nodejs(一)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/后端/">后端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/后端/node-js/">node.js</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 越学发现自己越无知，越感无力和恐慌，但我这一片炽热的心呐</span><br></pre></td></tr></table></figure>
<h2 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>V8引擎本身就是用于Chrome浏览器的JS解释部分，但是Ryan Dahl这哥们，鬼才般的，把这个V8搬到了服务器上，用于做服务器的软件。</p>
<p>Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。</p>
<p>Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。</p>
<p>但Node似乎有点不同：</p>
<p>● Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。</p>
<p>● 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。</p>
<p>），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。一会儿我们就将看到，Node.js没有web容器。</p>
<p>Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。</p>
<p>官网：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
<p>特点：Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>所谓的特点，就是Node.js是如何解决服务器高性能瓶颈问题的。</p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。</p>
<p>Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。</p>
<p>另外，带线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。</p>
<p>坏处，就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。</p>
<p>也就是说，单线程也能造成宏观上的“并发”。</p>
<h3 id="非阻塞I-O-non-blocking-I-O"><a href="#非阻塞I-O-non-blocking-I-O" class="headerlink" title="非阻塞I/O non-blocking I/O"></a>非阻塞I/O non-blocking I/O</h3><p>例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。</p>
<p>由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。</p>
<p>当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。</p>
<p>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。</p>
<h3 id="事件驱动event-driven"><a href="#事件驱动event-driven" class="headerlink" title="事件驱动event-driven"></a>事件驱动event-driven</h3><p>在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。</p>
<p>Node.js底层是C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度，这是鬼才才能想到的。针尖上的舞蹈，用一个线程，担负起了处理非常多的任务的使命。</p>
<h3 id="单线程，单线程的好处，减少了内存开销，操作系统的内存换页。"><a href="#单线程，单线程的好处，减少了内存开销，操作系统的内存换页。" class="headerlink" title="单线程，单线程的好处，减少了内存开销，操作系统的内存换页。"></a>单线程，单线程的好处，减少了内存开销，操作系统的内存换页。</h3><p>如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。</p>
<p>非阻塞I/O， 不会傻等I/O语句结束，而会执行后面的语句。</p>
<p>非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？</p>
<p>事件机制，事件环，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。</p>
<p>说是三个特点，实际上是一个特点，离开谁都不行，都玩儿不转了。</p>
<p>Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。</p>
<p>Node.js中所有的I/O都是异步的，回调函数，套回调函数。</p>
<h2 id="适合开发什么？"><a href="#适合开发什么？" class="headerlink" title="适合开发什么？"></a>适合开发什么？</h2><p>Node.js适合用来开发什么样的应用程序呢？</p>
<p>善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。</p>
<p>当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。</p>
<p>比如：</p>
<p>● 用户表单收集</p>
<p>● 考试系统</p>
<p>● 聊天室</p>
<p>● 图文直播</p>
<p>● 提供JSON的API（为前台Angular使用）</p>
<h1 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h1><p>Node.js中，将很多的功能，划分为了一个个mudule，大陆的书翻译为模块；台湾的书，翻译为模组。</p>
<p>这是因为，有一些程序需要使用fs功能（文件读取功能），有一些不用的，所以为了效率，你用啥，你就require啥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1 //这个案例简单讲解http模块</span><br><span class="line"></span><br><span class="line">2 //引用模块</span><br><span class="line"></span><br><span class="line">3 var http = require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">5 //创建一个服务器，回调函数表示接收到请求之后做的事情</span><br><span class="line"></span><br><span class="line">6 var server = http.createServer(function(req,res)&#123;</span><br><span class="line"></span><br><span class="line">7 //req参数表示请求，res表示响应</span><br><span class="line"></span><br><span class="line">8 console.log(&quot;服务器接收到了请求&quot; + req.url);</span><br><span class="line"></span><br><span class="line">9 res.end();</span><br><span class="line"></span><br><span class="line">10 &#125;);</span><br><span class="line"></span><br><span class="line">11 //监听端口</span><br><span class="line"></span><br><span class="line">12 server.listen(3000,&quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">设置一个响应头：</span><br><span class="line"></span><br><span class="line">1 res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/plain;charset=UTF8&quot;&#125;);</span><br><span class="line"></span><br><span class="line">我们现在来看一下req里面能够使用的东西。</span><br><span class="line"></span><br><span class="line">最关键的就是req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。</span><br><span class="line"></span><br><span class="line">我们比较关心的不是拿到URL，而是识别这个URL。</span><br><span class="line"></span><br><span class="line">识别URL，用到两个新模块，第一个就是url模块，第二个就是querystring模块</span><br><span class="line"></span><br><span class="line">字符串查询，用querystring处理</span><br><span class="line"></span><br><span class="line">1 querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;)</span><br><span class="line"></span><br><span class="line">2 // returns</span><br><span class="line"></span><br><span class="line">3 &#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">5 // Suppose gbkDecodeURIComponent function already exists,</span><br><span class="line"></span><br><span class="line">6 // it can decode `gbk` encoding string</span><br><span class="line"></span><br><span class="line">7 querystring.parse(&apos;w=%D6%D0%CE%C4&amp;foo=bar&apos;, null, null,</span><br><span class="line"></span><br><span class="line">8 &#123; decodeURIComponent: gbkDecodeURIComponent &#125;)</span><br><span class="line"></span><br><span class="line">9 // returns</span><br><span class="line"></span><br><span class="line">10 &#123; w: &apos;中文&apos;, foo: &apos;bar&apos; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文转自：https://www.cnblogs.com/binperson/p/5508190.html</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Shuyan Jing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jingshuyan.com/2019/04/16/4月16日nodejs/">https://jingshuyan.com/2019/04/16/4月16日nodejs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jingshuyan.com">拉斐尔</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/后端/">后端</a><a class="post-meta__tags" href="/tags/node-js/">node.js</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/16/4月16日nodejs-二/"><i class="fa fa-chevron-left">  </i><span>4月16日nodejs(二)</span></a></div><div class="next-post pull-right"><a href="/2019/04/14/4月14日面向对象复习/"><span>4月14日面向对象复习</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By Shuyan Jing</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>