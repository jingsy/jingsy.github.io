<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="自学前端的小白 弟中弟"><meta name="keywords" content><meta name="author" content="Shuyan Jing"><meta name="copyright" content="Shuyan Jing"><title>守得云开见月明 | 拉斐尔</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Shuyan Jing</div><div class="author-info__description text-center">自学前端的小白 弟中弟</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">拉斐尔</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">拉斐尔</div><div id="site-sub-title">守得云开见月明</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/19/4月19日js学习/">4月19日js学习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/前端/">前端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content"><h1 id="4月19日js学习"><a href="#4月19日js学习" class="headerlink" title="4月19日js学习"></a>4月19日js学习</h1><h2 id="使用递归获取后代元素"><a href="#使用递归获取后代元素" class="headerlink" title="使用递归获取后代元素"></a>使用递归获取后代元素</h2><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><pre><code>变量起作用的范围
</code></pre><h3 id="什么是块级作用域"><a href="#什么是块级作用域" class="headerlink" title="什么是块级作用域"></a>什么是块级作用域</h3><pre><code>JS中没有块级作用域，使用代码块限定的作用域就是块级作用域
</code></pre><h3 id="JS中的作用域叫做-词法作用域"><a href="#JS中的作用域叫做-词法作用域" class="headerlink" title="JS中的作用域叫做 词法作用域"></a>JS中的作用域叫做 词法作用域</h3><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><pre><code>在代码写好的时候，就能确定变量的作用域，这种作用域就是词法作用域

动态作用域.（是词法作用域就不可能是动态作用域）

在js当中，只有函数能创造作用域

var num = 123;
function f1(){
    console.log(num);  //如果是动态作用域打印的就是456 如果是词法作用域 打印123
}
function f2(){
    var num = 456;
    f1();
}
f2();
</code></pre><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><pre><code>JS代码的运行分两个阶段
* 预解析阶段
    * 变量名和函数提升
        将var声明的变量名和function开头的函数进行提升
        提升到当前作用域的最上方
* 执行阶段

注意：
    1.变量和函数同名的时候
        只提升函数，忽略变量名
    2.函数同名的时候
        都提升，但是后面的函数会覆盖前面的函数
    3.函数表达式，只会提升变量名，不会提后面的函数

    4.变量提升只会将变量和函数提升到当前作用域的最上方
    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funciton foo()&#123;</span><br><span class="line">   <span class="keyword">var</span> num =<span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    5.变量提升是分块 &lt;script&gt; 的

    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">foo()</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"第一个script标签内的函数"</span>)</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">foo()</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"第2个script标签内的函数"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

    6.条件式函数声明 能否被提升，取决于浏览器， 不推荐使用！！！
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo();//会报错，因为未被提升</span><br><span class="line">if(true)&#123;</span><br><span class="line">    function foo()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><pre><code>只要是函数都有作用域，函数内部的作用域可以访问函数外部的作用域
当多个函数嵌套的时候，就会形成一个链式的结构，这个就是作用域链
</code></pre><h2 id="绘制作用域链图的步骤"><a href="#绘制作用域链图的步骤" class="headerlink" title="绘制作用域链图的步骤"></a>绘制作用域链图的步骤</h2><pre><code>1.先绘制0级作用域链
2.在全局作用域中查找，变量和函数的声明，找到之后，将所有的变量和函数用小方格放在0级作用域链上
3.再从0级作用域链上的函数引出1级作用域链
4.再去每一个1级作用域链中查找变量和函数的声明，找到之后.....
5.以此重复，就画好了整个作用域链
</code></pre><h2 id="变量的搜索规则"><a href="#变量的搜索规则" class="headerlink" title="变量的搜索规则"></a>变量的搜索规则</h2><pre><code>1.首先在访问变量的作用域中查找该变量，如果找到直接使用
2.如果没有找到，去上一级作用域中继续查找，如果如果找到直接使用
3.如果没有找到，继续去上一级作用域中继续查找，直到全局作用域
4.如果找到了就用，如果没有直到就报错
</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h3><pre><code>一个封闭的对外不公开的包裹结构或空间
</code></pre><h3 id="js中的闭包是函数"><a href="#js中的闭包是函数" class="headerlink" title="js中的闭包是函数"></a>js中的闭包是函数</h3><h3 id="闭包要解决的问题"><a href="#闭包要解决的问题" class="headerlink" title="闭包要解决的问题"></a>闭包要解决的问题</h3><pre><code>1、在函数外部访问不到函数内部的数据
2、要解决的问题就是需要在外部间接的访问函数内部的数据
</code></pre><h3 id="闭包的基本结构"><a href="#闭包的基本结构" class="headerlink" title="闭包的基本结构"></a>闭包的基本结构</h3><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"数据"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"数据"</span>;</span><br><span class="line">    <span class="keyword">var</span> data1 = <span class="string">"数据1"</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getData:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;,</span><br><span class="line">        getData1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> data = <span class="string">"数据"</span>;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">           getData:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> data;</span><br><span class="line">           &#125;,</span><br><span class="line">           setData:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">               data = value;</span><br><span class="line">               <span class="keyword">return</span> data;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>如果把数据放在全局作用域内，那么所有人都可以随意修改，这个数据就不再可靠。</p>
<p>闭包可以创建一个私有空间，在这个空间内部的数据，外部无法直接访问</p>
<p>外部空间想要访问函数内部的数据，只能通过闭包提供的指定的方法，在这个方法内部<br>可以设置一些校验规则，让数据变得更加的安全。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/16/4月16日nodejs-二/">4月16日nodejs(二)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/后端/">后端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/后端/node-js/">node.js</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/node-js/">node.js</a></span><div class="content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 越学发现自己越无知，越感无力和恐慌，但我这一片炽热的心呐</span><br></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="在Node-js中，以模块为单位划分所有功能，并且提供了一个完整的模块加载机制，这时的我们可以将应用程序划分为各个不同的部分。"><a href="#在Node-js中，以模块为单位划分所有功能，并且提供了一个完整的模块加载机制，这时的我们可以将应用程序划分为各个不同的部分。" class="headerlink" title="在Node.js中，以模块为单位划分所有功能，并且提供了一个完整的模块加载机制，这时的我们可以将应用程序划分为各个不同的部分。"></a>在Node.js中，以模块为单位划分所有功能，并且提供了一个完整的模块加载机制，这时的我们可以将应用程序划分为各个不同的部分。</h3><p>不可能用一个js文件去写全部的业务。肯定要有MVC。</p>
<h3 id="狭义的说，每一个JavaScript文件都是一个模块；而多个JavaScript文件之间可以相互require，他们共同实现了一个功能，他们整体对外，又称为一个广义上的模块。"><a href="#狭义的说，每一个JavaScript文件都是一个模块；而多个JavaScript文件之间可以相互require，他们共同实现了一个功能，他们整体对外，又称为一个广义上的模块。" class="headerlink" title="狭义的说，每一个JavaScript文件都是一个模块；而多个JavaScript文件之间可以相互require，他们共同实现了一个功能，他们整体对外，又称为一个广义上的模块。"></a>狭义的说，每一个JavaScript文件都是一个模块；而多个JavaScript文件之间可以相互require，他们共同实现了一个功能，他们整体对外，又称为一个广义上的模块。</h3><h3 id="Node-js中，一个JavaScript文件中定义的变量、函数，都只在这个文件内部有效。当需要从此JS文件外部引用这些变量、函数时，必须使用exports对象进行暴露。使用者要用require-命令引用这个JS文件。"><a href="#Node-js中，一个JavaScript文件中定义的变量、函数，都只在这个文件内部有效。当需要从此JS文件外部引用这些变量、函数时，必须使用exports对象进行暴露。使用者要用require-命令引用这个JS文件。" class="headerlink" title="Node.js中，一个JavaScript文件中定义的变量、函数，都只在这个文件内部有效。当需要从此JS文件外部引用这些变量、函数时，必须使用exports对象进行暴露。使用者要用require()命令引用这个JS文件。"></a>Node.js中，一个JavaScript文件中定义的变量、函数，都只在这个文件内部有效。当需要从此JS文件外部引用这些变量、函数时，必须使用exports对象进行暴露。使用者要用require()命令引用这个JS文件。</h3><p>foo.js文件中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 var msg = &quot;你好&quot;;</span><br><span class="line"></span><br><span class="line">3 exports.msg = msg;</span><br></pre></td></tr></table></figure></p>
<p>msg这个变量，是一个js文件内部才有作用域的变量。</p>
<p>如果别人想用这个变量，那么就要用exports进行暴露。</p>
<p>使用者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 var foo = require(&quot;./test/foo.js&quot;);</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">3 console.log(foo.msg);</span><br></pre></td></tr></table></figure></p>
<p>使用者用foo来接收exports对象，也就是说，这里的foo变量，就是文件中的exports变量。</p>
<h3 id="一个JavaScript文件，可以向外exports无数个变量、函数。但是require的时候，仅仅需要require这个JS文件一次。使用的它的变量、函数的时候，用点语法即可。所以，无形之中，增加了一个顶层命名空间。"><a href="#一个JavaScript文件，可以向外exports无数个变量、函数。但是require的时候，仅仅需要require这个JS文件一次。使用的它的变量、函数的时候，用点语法即可。所以，无形之中，增加了一个顶层命名空间。" class="headerlink" title="一个JavaScript文件，可以向外exports无数个变量、函数。但是require的时候，仅仅需要require这个JS文件一次。使用的它的变量、函数的时候，用点语法即可。所以，无形之中，增加了一个顶层命名空间。"></a>一个JavaScript文件，可以向外exports无数个变量、函数。但是require的时候，仅仅需要require这个JS文件一次。使用的它的变量、函数的时候，用点语法即可。所以，无形之中，增加了一个顶层命名空间。</h3><p>js文件中，可以用exports暴露很多东西，比如函数、变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 var msg = &quot;你好&quot;;</span><br><span class="line"></span><br><span class="line">2 var info = &quot;呵呵&quot;;</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">4 function showInfo()&#123;</span><br><span class="line"></span><br><span class="line">5 console.log(info);</span><br><span class="line"></span><br><span class="line">6 &#125;</span><br><span class="line"></span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">8 exports.msg = msg;</span><br><span class="line"></span><br><span class="line">9 exports.info = info;</span><br><span class="line"></span><br><span class="line">10 exports.showInfo = showInfo;</span><br></pre></td></tr></table></figure></p>
<h3 id="在使用者中，只需要require一次。"><a href="#在使用者中，只需要require一次。" class="headerlink" title="在使用者中，只需要require一次。"></a>在使用者中，只需要require一次。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 var foo = require(&quot;./test/foo.js&quot;);</span><br></pre></td></tr></table></figure>
<p>相当于增加了顶层变量。所有的函数、变量都要从这个顶层变量走：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 console.log(foo.msg);</span><br><span class="line"></span><br><span class="line">2 console.log(foo.info);</span><br><span class="line"></span><br><span class="line">3 foo.showInfo();</span><br></pre></td></tr></table></figure></p>
<h3 id="Node中，js文件和js文件，就是被一个个exports和require构建成为网状的。"><a href="#Node中，js文件和js文件，就是被一个个exports和require构建成为网状的。" class="headerlink" title="Node中，js文件和js文件，就是被一个个exports和require构建成为网状的。"></a>Node中，js文件和js文件，就是被一个个exports和require构建成为网状的。</h3><p>不是靠html文件统一在一起的。</p>
<h3 id="可以将一个JavaScript文件中，描述一个类。用"><a href="#可以将一个JavaScript文件中，描述一个类。用" class="headerlink" title="可以将一个JavaScript文件中，描述一个类。用"></a>可以将一个JavaScript文件中，描述一个类。用</h3><p>module.export = 构造函数名;</p>
<p>的方式向外暴露一个类。</p>
<p>也就是说，js文件和js文件之间有两种合作的模式：</p>
<p>1） 某一个js文件中，提供了函数，供别人使用。 只需要暴露函数就行了； exports.msg=msg;</p>
<p>2） 某一个js文件，描述了一个类。 module.exports = People;</p>
<h3 id="如果在require命令中，这么写"><a href="#如果在require命令中，这么写" class="headerlink" title="如果在require命令中，这么写:"></a>如果在require命令中，这么写:</h3><p>1 var foo = require(“foo.js”); //没有写./， 所以不是一个相对路径。是一个特殊的路径</p>
<p>那么Node.js将该文件视为node_modules目录下的一个文件</p>
<h3 id="node-modules文件夹并不一定在同级目录里面，在任何直接祖先级目录中，都可以。甚至可以放到NODE-PATH环境变量的文件夹中。这样做的好处稍后你将知道：分享项目的时候，不需要带着modules一起给别人。"><a href="#node-modules文件夹并不一定在同级目录里面，在任何直接祖先级目录中，都可以。甚至可以放到NODE-PATH环境变量的文件夹中。这样做的好处稍后你将知道：分享项目的时候，不需要带着modules一起给别人。" class="headerlink" title="node_modules文件夹并不一定在同级目录里面，在任何直接祖先级目录中，都可以。甚至可以放到NODE_PATH环境变量的文件夹中。这样做的好处稍后你将知道：分享项目的时候，不需要带着modules一起给别人。"></a>node_modules文件夹并不一定在同级目录里面，在任何直接祖先级目录中，都可以。甚至可以放到NODE_PATH环境变量的文件夹中。这样做的好处稍后你将知道：分享项目的时候，不需要带着modules一起给别人。</h3><h3 id="我们可以使用文件夹来管理模块，比如"><a href="#我们可以使用文件夹来管理模块，比如" class="headerlink" title="我们可以使用文件夹来管理模块，比如"></a>我们可以使用文件夹来管理模块，比如</h3><p>1 var bar = require(“bar”);</p>
<p>那么Node.js将会去寻找node_modules目录下的bar文件夹中的index.js去执行。</p>
<p>每一个模块文件夹中，推荐都写一个package.json文件，这个文件的名字不能改。node将自动读取里面的配置。有一个main项，就是入口文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &#123;</span><br><span class="line"></span><br><span class="line">2 &quot;name&quot;: &quot;kaoladebar&quot;,</span><br><span class="line"></span><br><span class="line">3 &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line"></span><br><span class="line">4 &quot;main&quot; : &quot;app.js&quot;</span><br><span class="line"></span><br><span class="line">5 &#125;</span><br></pre></td></tr></table></figure></p>
<p>package.json文件，要放到模块文件夹的根目录去。</p>
<h3 id="我们刚才学习了，模块就是一些功能的封装，所以一些成熟的、经常使用的功能，都有人封装成为了模块。并且放到了社区中，供人免费下载。"><a href="#我们刚才学习了，模块就是一些功能的封装，所以一些成熟的、经常使用的功能，都有人封装成为了模块。并且放到了社区中，供人免费下载。" class="headerlink" title="我们刚才学习了，模块就是一些功能的封装，所以一些成熟的、经常使用的功能，都有人封装成为了模块。并且放到了社区中，供人免费下载。"></a>我们刚才学习了，模块就是一些功能的封装，所以一些成熟的、经常使用的功能，都有人封装成为了模块。并且放到了社区中，供人免费下载。</h3><p>这个伟大的社区，叫做npm。 也是一个工具名字 node package management<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.npmjs.com/</span><br></pre></td></tr></table></figure></p>
<p>去社区搜索需求，然后点进去，看api。</p>
<h3 id="如果要配置一个模块，那么直接在cmd使用"><a href="#如果要配置一个模块，那么直接在cmd使用" class="headerlink" title="如果要配置一个模块，那么直接在cmd使用"></a>如果要配置一个模块，那么直接在cmd使用</h3><p>1 npm install 模块名字</p>
<p>就可以安装。 模块名字全球唯一。</p>
<p>安装的时候，要注意，命令提示符的所在位置。</p>
<p>1.我们的依赖包，可能在随时更新，我们永远想保持更新，或者某持某一个版本；</p>
<p>2.项目越来越大的时候，给别人看的时候，没有必要再次共享我们引用的第三方模块。</p>
<p>我们可以用package.json来管理依赖。</p>
<p>在cmd中，使用npm init可以初始化一个package.json文件，用回答问题的方式生成一个新的package.json文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文转自：https://www.cnblogs.com/binperson/p/5508190.html</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/16/4月16日nodejs/">4月16日nodejs(一)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/后端/">后端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/后端/node-js/">node.js</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/node-js/">node.js</a></span><div class="content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 越学发现自己越无知，越感无力和恐慌，但我这一片炽热的心呐</span><br></pre></td></tr></table></figure>
<h2 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>V8引擎本身就是用于Chrome浏览器的JS解释部分，但是Ryan Dahl这哥们，鬼才般的，把这个V8搬到了服务器上，用于做服务器的软件。</p>
<p>Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。</p>
<p>Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。</p>
<p>但Node似乎有点不同：</p>
<p>● Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。</p>
<p>● 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。</p>
<p>），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。一会儿我们就将看到，Node.js没有web容器。</p>
<p>Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。</p>
<p>官网：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
<p>特点：Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>所谓的特点，就是Node.js是如何解决服务器高性能瓶颈问题的。</p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。</p>
<p>Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。</p>
<p>另外，带线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。</p>
<p>坏处，就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。</p>
<p>也就是说，单线程也能造成宏观上的“并发”。</p>
<h3 id="非阻塞I-O-non-blocking-I-O"><a href="#非阻塞I-O-non-blocking-I-O" class="headerlink" title="非阻塞I/O non-blocking I/O"></a>非阻塞I/O non-blocking I/O</h3><p>例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。</p>
<p>由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。</p>
<p>当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。</p>
<p>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。</p>
<h3 id="事件驱动event-driven"><a href="#事件驱动event-driven" class="headerlink" title="事件驱动event-driven"></a>事件驱动event-driven</h3><p>在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。</p>
<p>Node.js底层是C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度，这是鬼才才能想到的。针尖上的舞蹈，用一个线程，担负起了处理非常多的任务的使命。</p>
<h3 id="单线程，单线程的好处，减少了内存开销，操作系统的内存换页。"><a href="#单线程，单线程的好处，减少了内存开销，操作系统的内存换页。" class="headerlink" title="单线程，单线程的好处，减少了内存开销，操作系统的内存换页。"></a>单线程，单线程的好处，减少了内存开销，操作系统的内存换页。</h3><p>如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。</p>
<p>非阻塞I/O， 不会傻等I/O语句结束，而会执行后面的语句。</p>
<p>非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？</p>
<p>事件机制，事件环，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。</p>
<p>说是三个特点，实际上是一个特点，离开谁都不行，都玩儿不转了。</p>
<p>Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。</p>
<p>Node.js中所有的I/O都是异步的，回调函数，套回调函数。</p>
<h2 id="适合开发什么？"><a href="#适合开发什么？" class="headerlink" title="适合开发什么？"></a>适合开发什么？</h2><p>Node.js适合用来开发什么样的应用程序呢？</p>
<p>善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。</p>
<p>当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。</p>
<p>比如：</p>
<p>● 用户表单收集</p>
<p>● 考试系统</p>
<p>● 聊天室</p>
<p>● 图文直播</p>
<p>● 提供JSON的API（为前台Angular使用）</p>
<h1 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h1><p>Node.js中，将很多的功能，划分为了一个个mudule，大陆的书翻译为模块；台湾的书，翻译为模组。</p>
<p>这是因为，有一些程序需要使用fs功能（文件读取功能），有一些不用的，所以为了效率，你用啥，你就require啥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1 //这个案例简单讲解http模块</span><br><span class="line"></span><br><span class="line">2 //引用模块</span><br><span class="line"></span><br><span class="line">3 var http = require(&quot;http&quot;);</span><br><span class="line"></span><br><span class="line">5 //创建一个服务器，回调函数表示接收到请求之后做的事情</span><br><span class="line"></span><br><span class="line">6 var server = http.createServer(function(req,res)&#123;</span><br><span class="line"></span><br><span class="line">7 //req参数表示请求，res表示响应</span><br><span class="line"></span><br><span class="line">8 console.log(&quot;服务器接收到了请求&quot; + req.url);</span><br><span class="line"></span><br><span class="line">9 res.end();</span><br><span class="line"></span><br><span class="line">10 &#125;);</span><br><span class="line"></span><br><span class="line">11 //监听端口</span><br><span class="line"></span><br><span class="line">12 server.listen(3000,&quot;127.0.0.1&quot;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">设置一个响应头：</span><br><span class="line"></span><br><span class="line">1 res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/plain;charset=UTF8&quot;&#125;);</span><br><span class="line"></span><br><span class="line">我们现在来看一下req里面能够使用的东西。</span><br><span class="line"></span><br><span class="line">最关键的就是req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。</span><br><span class="line"></span><br><span class="line">我们比较关心的不是拿到URL，而是识别这个URL。</span><br><span class="line"></span><br><span class="line">识别URL，用到两个新模块，第一个就是url模块，第二个就是querystring模块</span><br><span class="line"></span><br><span class="line">字符串查询，用querystring处理</span><br><span class="line"></span><br><span class="line">1 querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;)</span><br><span class="line"></span><br><span class="line">2 // returns</span><br><span class="line"></span><br><span class="line">3 &#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">5 // Suppose gbkDecodeURIComponent function already exists,</span><br><span class="line"></span><br><span class="line">6 // it can decode `gbk` encoding string</span><br><span class="line"></span><br><span class="line">7 querystring.parse(&apos;w=%D6%D0%CE%C4&amp;foo=bar&apos;, null, null,</span><br><span class="line"></span><br><span class="line">8 &#123; decodeURIComponent: gbkDecodeURIComponent &#125;)</span><br><span class="line"></span><br><span class="line">9 // returns</span><br><span class="line"></span><br><span class="line">10 &#123; w: &apos;中文&apos;, foo: &apos;bar&apos; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文转自：https://www.cnblogs.com/binperson/p/5508190.html</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/14/4月14日面向对象复习/">4月14日面向对象复习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/前端/">前端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content"><h1 id="面向对象复习"><a href="#面向对象复习" class="headerlink" title="面向对象复习"></a>面向对象复习</h1><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><pre><code>面向对象是一种编程思想
    把解决问题的关注点放到解决问题所需要的过程
面向过程是一种思想
    把解决问题的关注点放到解决问题所需要的每一个步骤上
</code></pre><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><pre><code>1.封装
2.继承
3.多态
</code></pre><h2 id="什么对象"><a href="#什么对象" class="headerlink" title="什么对象"></a>什么对象</h2><pre><code>万物皆对象
</code></pre><h2 id="什么是js对象"><a href="#什么是js对象" class="headerlink" title="什么是js对象"></a>什么是js对象</h2><pre><code>键值对的集合（无序）
</code></pre><h2 id="名词提炼"><a href="#名词提炼" class="headerlink" title="名词提炼"></a>名词提炼</h2><pre><code>一句话的所有名词都可以当作对象
</code></pre><h2 id="如何用js模拟对象"><a href="#如何用js模拟对象" class="headerlink" title="如何用js模拟对象"></a>如何用js模拟对象</h2><pre><code>属性对应特征
方法对应行为
</code></pre><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><pre><code>1.使用对象字面量
2.使用内置的构造函数Object
3.使用简单工厂函数（不推荐）
4.自定义构造函数
</code></pre><h2 id="传统构造函数存在的问题"><a href="#传统构造函数存在的问题" class="headerlink" title="传统构造函数存在的问题"></a>传统构造函数存在的问题</h2><pre><code>如果把方法定义在函数中，每创建一个对象，都会新创建一个方法，这样会造成资源浪费

如何解决问题？
1.把方法提取出来定义在全局，在构造函数中引用该方法
2.使用原型来解决
    原型中的所有成员都可以被跟其所有关联的对象所访问
</code></pre><h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><pre><code>1.构造函数创建的时候，系统会默认的为这个构造函数创建并且关联一个对象————这个对象就是原型对象

2.这个原型对象默认是一个空的对象，可以被所有该构造函数所实例化出来的对象所访问
</code></pre><h2 id="原型的使用方式（实现原型继承的方式）"><a href="#原型的使用方式（实现原型继承的方式）" class="headerlink" title="原型的使用方式（实现原型继承的方式）"></a>原型的使用方式（实现原型继承的方式）</h2><pre><code>1.利用对象的动态特性给原型对象添加成员

2.直接替换原型对象

3.通过混入的方式给原型对象添加成员
</code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><pre><code>每个构造函数都有原型对象，每一个原型对象都有构造函数，这样就形成了一个链式结构
</code></pre><h2 id="继承实现方式"><a href="#继承实现方式" class="headerlink" title="继承实现方式"></a>继承实现方式</h2><pre><code>1.混入式继承 for in
2.原型继承 
    通过更改原型链的结构实现的继承

3.经典继承 Object.create() 有兼容性问题
// var 对象名 = Object.create(要继承的对象);
</code></pre><h2 id="Object-prototype的成员"><a href="#Object-prototype的成员" class="headerlink" title="Object.prototype的成员"></a>Object.prototype的成员</h2><pre><code>constructor 属性 指向该原型相关的构造函数

hasOwnProperty 方法 判断对象本身是否拥有某个属性

isPrototypeOf 方法 判断一个对象是不是另一个对象的原型对象

propertyIsEnumerable 方法 先判断属性是否属于对象本身 如果是 就继续判断属性是否可以被遍历 如果不是 返回 false 如果是 返回true

toString toLocaleString 方法     转换成字符串
toLocaleString转换为本地格式的字符串                   
valueOf 方法 当对象参加运算的时候 会首先调用valueOf方法获取对象的值，如果获取的值不能参与运算 则调用toString方法

__proto__ 属性 指向对象关联的原型对象
</code></pre><h2 id="Function-eval"><a href="#Function-eval" class="headerlink" title="Function eval"></a>Function eval</h2><pre><code>都可以将字符串转换为代码
不同点：
    Function创建出来的是函数 不会直接调用 除非手动调用

    eval直接可以将字符串转换为代码并执行
</code></pre><h2 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h2><pre><code>函数内部的一个对象，在函数调用的时候，系统会默认的将所有实参存入这个对象
arguments.length 长度
arguments.callee 指向当前函数
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/14/4月14日下午/">4月14日下午js学习总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/前端/">前端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content"><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="混入式继承"><a href="#混入式继承" class="headerlink" title="混入式继承"></a>混入式继承</h3><pre><code>for in
使用for in 遍历对象的属性，将所有的属性添加到另外一个对象上
这时候就可以称 对象2 继承自 对象1
</code></pre><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><pre><code>利用对象的动态特性，为原型对象添加成员
直接替换原型对象
   1.替换前的对象在替换之后所有成员都丢失了
   2.替换原型对象的时候需要手动去指定将要替换的原型对象 指定constructor
利用混入给原型对象添加成员
</code></pre><h3 id="经典继承"><a href="#经典继承" class="headerlink" title="经典继承"></a>经典继承</h3><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象<span class="number">1</span> = <span class="built_in">Object</span>.create(对象<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

    这个时候创建出来的对象继承自对象2

    Object.create存在兼容性问题
    如何解决？
    解决方法：
        1.首先监测浏览器是否支持Object.create()如果不支持,则手动添加
        2.自定义函数，在函数内部判断浏览器是否支持Object.create(),如果不支持则手动创建对象返回，如果支持，则直接调用

        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">Object</span>.create)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Object</span>.create(obj);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">		F.prototype = obj;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> F();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h3><pre><code>每个构造函数都有原型对象，每个对象都有构造函数，
每个构造函数的原型对象都是对象，也就有构造函数，
然后就形成了一个链式的结构
</code></pre><h3 id="原型继承是什么"><a href="#原型继承是什么" class="headerlink" title="原型继承是什么"></a>原型继承是什么</h3><pre><code>通过修改原型链的结构，实现继承的方式
</code></pre><h3 id="对象和原型的成员关系"><a href="#对象和原型的成员关系" class="headerlink" title="对象和原型的成员关系"></a>对象和原型的成员关系</h3><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

p对象包含的成员有：Person.prototype中的成员 和自身拥有的成员
Person.prototype拥有的成员有：Object.prototype的成员和自身的成员

所以：p对象可以访问 Person.prototype 和 Object.prototype 中的所有成员
</code></pre><h3 id="Object-prototype的成员"><a href="#Object-prototype的成员" class="headerlink" title="Object.prototype的成员"></a>Object.prototype的成员</h3><pre><code>* constructor:指向和该原型相关的构造函数
* hasOwnProperty 方法：判断对象本身是否拥有某个属性
* properIsEnumerable 方法：1.判断属性是否属于对象本身，以及判断属性是否可以被遍历
* toString toLocaleString: 将对象转换为字符串
toLocaleString 转换为字符串的时候 应用的是本地的设置格式
* valueOf 方法： 在对象参与运算的时候， 首先调用valueOf方法获取对象的值，如果该值无法参与运算，将会调用出toString方法
* __proto__ 属性：指向当前对象的原型对象
</code></pre><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><pre><code>可以用Function来创建函数
</code></pre><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><pre><code>    * 直接申明函数
    * 函数表达式
    * new Function（）

可以用Function来创建函数
语法：
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">//创建一个空的函数</span></span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"函数体"</span>); <span class="comment">//创建一个没有参数的函数</span></span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">new</span> <span class="built_in">Function</span>(“参数<span class="number">1</span><span class="string">",“参数2"</span>,函数体<span class="string">"); //当给function传多个参数的时候，最后一个参数为函数体，前面参数为创建出的这个参数的形参</span></span><br><span class="line"><span class="string">//function接受的所有参数都是字符串类型的</span></span><br></pre></td></tr></table></figure>
</code></pre><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><pre><code>arguments对象是函数内部的一个对象，调用时候，函数会把所有的参数存入该对象
注意：不管有没有形参，实参都会被存入该对象
</code></pre><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><pre><code>可以将字符串转换为js代码并执行

注意： 当使用eval解析JSON格式字符串的时候
1.可以在JSON格式字符串前面拼接 “var 变量名 =”
如：    eval(&quot;var 变量名=&quot; +json格式的字符串)

2.可以在JSON格式字符串前后拼接（）
    eval(&quot;(&quot;+JSON格式字符串+&quot;)&quot;)
</code></pre><h2 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h2><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><pre><code>是指构造函数的属性和方法
</code></pre><h3 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h3><pre><code>是指实例的属性和方法
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/13/4月13日上午js学习总结/">4月13日上午js学习总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/前端/">前端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content"><h1 id="4月13日上午javascript学习总结"><a href="#4月13日上午javascript学习总结" class="headerlink" title="4月13日上午javascript学习总结"></a>4月13日上午javascript学习总结</h1><h3 id="逻辑运算总结"><a href="#逻辑运算总结" class="headerlink" title="逻辑运算总结"></a>逻辑运算总结</h3><h3 id="逻辑中断（短路运算）"><a href="#逻辑中断（短路运算）" class="headerlink" title="逻辑中断（短路运算）"></a>逻辑中断（短路运算）</h3><pre><code>//表达式1 || 表达式2
//如果表达式1 为 true 返回表达式1
//如果表达式1 为 false 返回表达式2
//表达式1 &amp;&amp; 表达式2
//如果表达式1 为 true 判断表达式2 若为真 返回2，若为假返回 2
//如果表达式1 为 false 直接返回表达式1
</code></pre><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><pre><code>·封装
·继承
    自己没有的，拿别人的过来用
·多态
    父类引用指向子类的对象（js中用不到）
</code></pre><h3 id="创建对象的四种方式"><a href="#创建对象的四种方式" class="headerlink" title="创建对象的四种方式"></a>创建对象的四种方式</h3><pre><code>·使用字面量创建对象
···js
    var o = {key:value,key:value}
    缺点：用一个建一个，资源浪费
···

·使用内置构造函数创建对象
    var o = new Object();
    var o = new Array();
    缺点：创建出来的都是空的对象，要手动添加，代码重复

·封装简单的工厂函数（不推荐使用）
    function createObj(){
        var obj = {};
        obj.xxx= xxx;
        return obj;
}

`自定义构造函数
function X {
this.xxx=xxx;
//```
</code></pre><p>}<br>    1.构造函数一般和new关键词一起使用<br>    2.首字母大写<br>    3.构造函数返回值默认为新创建好的对象，如果手动返回基本对象数据类型<br>    ，不影响，还是默认返回值，如果返回的是对象，那么新创建出来的对象是不会<br>    返回，取而代之的是reurn后面的对象</p>
<pre><code>构造函数步骤
1.new关键字创建对象
2.调用构造函数，将new创建出来的对象赋值给构造函数的this
3.使用this给新创建出来的对象增加成员
4.默认返回新创建出来的这个对象
</code></pre><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="1-构造函数存在的问题"><a href="#1-构造函数存在的问题" class="headerlink" title="1.构造函数存在的问题"></a>1.构造函数存在的问题</h4><pre><code>构造函数中的方法，在每次新创建一个对象的时候，该对象都会重新的创建一次这个方法，每个对象独占一个，但是该方法内容完全一样，这样造成了资源浪费

解决办法
1.将构造函数内的方法，进行提取，放在构造函数外面，在构造函数外面进行引用赋值，那么创建出来的对象都会指向构造函数外面的这个函数，达到共享的目的

缺点：全局变量增多，造成污染 2.代码结构混乱，不好维护
</code></pre><h4 id="2-使用原型"><a href="#2-使用原型" class="headerlink" title="2.使用原型"></a>2.使用原型</h4><pre><code>什么是原型：构造函数在创建的时候，系统会默认的创建并关联一个对象，这个对象就是原型，默认是空对象，里面有个contstrucor属性指向构造函数
</code></pre><h4 id="3-原型的作用"><a href="#3-原型的作用" class="headerlink" title="3.原型的作用"></a>3.原型的作用</h4><pre><code>1.原型对象中的成员可以被使用和它关联的构造函数创建出来的所有对象共享
</code></pre><h4 id="4-原型对象的使用"><a href="#4-原型对象的使用" class="headerlink" title="4.原型对象的使用"></a>4.原型对象的使用</h4><pre><code>1.使用对象的动态特性，为原型对象添加成员
2.直接替换原型对象

注意事项⚠️：
    直接替换原型对象，会导致替换之前创建的对象的原型 和 替换之后创建的对象的原型 不一致
</code></pre><h4 id="5-原型的使用注意事项："><a href="#5-原型的使用注意事项：" class="headerlink" title="5.原型的使用注意事项："></a>5.原型的使用注意事项：</h4><pre><code>1.使用对象访问属性的时候，会在对象中查找，如果找到了就使用，如果没找到就会去原型中进行查找
2.使用对象设置属性的时候，不会在原型中查找，不会去原型中查找，如果在对象本身中没有找到这个属性，则给该对象新增一个属性。如果对象中有这个属性，则进行修改
3.如果在原型对象中有引用类型的属性，那么使用对象进行修改该属性内容的时候，则其他所有跟这个原型对象相关的对象 都会受到印象

Person.prototype.car = {};
var p = new Person();
p.car = {};//这是修改属性
p.car.brand=&quot;&quot;; //这是修改属性的内容

4.一般情况下，不会将属性添加到原型对象中，只会将需要共享的方法添加到原型对象中
</code></pre><h4 id="6-proto"><a href="#6-proto" class="headerlink" title="6.proto"></a>6.<strong>proto</strong></h4><pre><code>1.这个属性不是标准属性，所以存在通用性问题
2.一般不推荐使用这个属性
3.调试到时候可以使用
4.这个属性是原型中的属性
</code></pre><h4 id="7-替换原型的时候的注意事项："><a href="#7-替换原型的时候的注意事项：" class="headerlink" title="7.替换原型的时候的注意事项："></a>7.替换原型的时候的注意事项：</h4><pre><code>在新替换的原型中，没有contructor属性，会影响三角结构关系的合理性
所以，在新替换的原型中，手动添加contructor属性
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/10/交互设计要读的书单/">交互设计要读的书单</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/交互设计/">交互设计</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/交互设计/">交互设计</a></span><div class="content"><h1 id="交互设计需要读的书单"><a href="#交互设计需要读的书单" class="headerlink" title="交互设计需要读的书单"></a>交互设计需要读的书单</h1><p>《交互设计精髓》、<br> 设计心理学，<br> about face，<br>《交互设计指南》、<br>《微交互》、<br>《用户体验要素》、<br>《简约至上》、<br>《破茧成蝶》<br>《Don’t make me think》、<br>《瞬间之美》、<br>《web表单设计》、<br>《方寸指间》<br>《在你身边，为你设计》、<br> 阿里巴巴《U一点料》、<br>《腾讯网UED体验设计之旅》</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/09/new/">产品经理学习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/产品经理/">产品经理</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/产品经理/">产品经理</a></span><div class="content"><h1 id="产业地图："><a href="#产业地图：" class="headerlink" title="产业地图："></a>产业地图：</h1><h2 id="什么是产业地图？？"><a href="#什么是产业地图？？" class="headerlink" title="什么是产业地图？？"></a>什么是产业地图？？</h2><p>产业格局的结构化总览</p>
<h2 id="产业地图能获取什么信息？"><a href="#产业地图能获取什么信息？" class="headerlink" title="产业地图能获取什么信息？"></a>产业地图能获取什么信息？</h2><p>1.行业运转规律（上下游关系，如何玩）<br>2.行业拆解<br>3.竞争环境</p>
<h2 id="产业地图的梳理："><a href="#产业地图的梳理：" class="headerlink" title="产业地图的梳理："></a>产业地图的梳理：</h2><p>横向：分解行业阶段<br>纵向：阶段分析与分类 填充：行业玩家 </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/09/github的一些总结/">github的一些总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/git/">git</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/git/">git</a></span><div class="content"><h2 id="git如何连接github远程仓库"><a href="#git如何连接github远程仓库" class="headerlink" title="git如何连接github远程仓库"></a>git如何连接github远程仓库</h2><h3 id="准备1-github账号"><a href="#准备1-github账号" class="headerlink" title="准备1.github账号"></a>准备1.github账号</h3><h3 id="准备2-下载git（下载方式查看git官方文档）"><a href="#准备2-下载git（下载方式查看git官方文档）" class="headerlink" title="准备2.下载git（下载方式查看git官方文档）"></a>准备2.下载git（下载方式查看git官方文档）</h3><p>1.cd到你要上传的文件夹(可在终端之间打cd 然后拖入你要上传的文件夹回车即可)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init <span class="string">"新建一个本地仓库"</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .  <span class="string">"添加所有文件到临时仓库"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"x”  添加文件到工作仓库</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin + url  <span class="string">"(url为你的github仓库链接)"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master --allow-unrelated-histories <span class="string">"(因为github会拒绝合并不相关历史，所以使用这个代码)"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>成功！</p>
<h2 id="git如何同步修改github远程仓库"><a href="#git如何同步修改github远程仓库" class="headerlink" title="git如何同步修改github远程仓库"></a>git如何同步修改github远程仓库</h2><p>cd到要修改的仓库的本地文件，push前先将远程repository修改pull下来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure></p>
<p>2.删除你要移除的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r <span class="comment">#文件名</span></span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r --cached  .setting <span class="comment">#--cached不会把本地的.setting删除</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>然后push</p>
<h2 id="一些指令"><a href="#一些指令" class="headerlink" title="一些指令"></a>一些指令</h2><p>pwd 查看路径<br>ls -ah显示隐藏的git<br>git status查看当前状态<br>git diff查看修改<br>git log 查看修改日志<br>git中 HEAD表示当前版本 </p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By Shuyan Jing</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>